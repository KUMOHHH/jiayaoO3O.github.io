---
title: 198.打家劫舍
date: 2019-05-20 10:32:49
tags: leetcode
categories: [算法学习,leetcode]
---
## 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。

**示例 1:**

```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2:**

```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

<!-- more -->

## 思路

这道题是一道典型的动态规划题目.

可以创建一个数组sum[],动态地记录偷或者不偷这一家房子会得到的最高金额.

如果决定偷,那sum[i]=sum[i-2]+nums[i].

如果决定不偷,那这个位置的最高金额和上一个位置的一样sum[i]=sum[i-1].

判断偷不偷的依据是看两者谁提供的金额更高.

## 代码
```c#
public int Rob(int[] nums)
{
    if (nums == null || nums.Length == 0)
    {
        return 0;
    }
    if (nums.Length == 1)
    {
        return nums[0];
    }
    int[] sum = new int[nums.Length];
    sum[0] = nums[0];
    sum[1] = Math.Max(nums[0], nums[1]);
    for (int i = 2; i < sum.Length; i++)
    {
        sum[i] = Math.Max(sum[i - 1], sum[i - 2] + nums[i]);//判断偷和不偷得到的最高金额.
    }
    return sum[sum.Length - 1];
}
```